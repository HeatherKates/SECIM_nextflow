---
title: "Reporting analysis of untargeted metabolomics data"
author: "Southeast Center for Integrated Metabolomics"
date: "`r format(Sys.time(), '%m/%d/%y')`"
output: 
  html_document:
    toc: true
    number_sections: 1
    theme: cosmo
    highlight: tango
    code_folding: show
  pdf_document: default
  pandoc_args: [
      "+RTS", "-K16000m",
      "-RTS"
    ]
---

```{css, echo=FALSE}
/* Adjust the width to control the size of each plot */
#up-plot-container, #down-plot-container {
    width: 100%; /* Each plot takes up the full width of its container */
    margin-bottom: 400px; /* Add space between the plots (adjust as needed) */
    clear: both; /* Ensure each plot starts on a new line */
    
}
```

```{r, include=FALSE}
#version update V3 from v2.1 is how the sections are hyperlinked
knitr::opts_chunk$set(
   echo = FALSE, warning = FALSE,message = FALSE
)
```

```{r include=FALSE,message=FALSE,warning=FALSE}
library(SummarizedExperiment)
library(MetaboDiff)
#library(cowplot)
#library(ggVennDiagram)
#library(VennDiagram)
library(RColorBrewer)
library(omu)
library(ggplot2)
library(ggrepel)
library(pheatmap)
library(KEGGREST)
library(FELLA)
library(org.Hs.eg.db)
library(tibble)
library(igraph)
library(gridExtra)
library(stringr)
library(S4Vectors)
library(SummarizedExperiment)
library(downloadthis)
#library(ggiraph)
library(heatmaply)
library(ddpcr) 
library(DT)
library(stringi)
library(data.table)
library(metid)
library(xlsx)
library(matrixStats)
library(readxl)
library(qmtools)
library(stats)
library(emmeans)
library(broom)
library(plyr)
library(dplyr)
library(plotly)
library(htmltools)
library(car)
```

```{r}
# Function to modify data frames in the list
modify_data_frame <- function(df) {
  if ("Level" %in% colnames(df)) {
    # Rename the column
    colnames(df)[colnames(df) == "Level"] <- "ID_confidence"
    
    # Change the values
    df$ID_confidence <- as.character(df$ID_confidence)
    df$ID_confidence[df$ID_confidence == "1"] <- "High"
    df$ID_confidence[df$ID_confidence == "3"] <- "Low"
  }
  return(df)
}

# Iterate over the list and apply the function conditionally
ReportInput <- lapply(ReportInput, function(x) {
  if (is.data.frame(x)) {
    x <- modify_data_frame(x)
  }
  return(x)
})
```

```{r}
Client_Data_Download <- ReportInput

if(test_type %in% c("lmm","repeated_measures_anova")){
if(nrow(Client_Data_Download[["report_results"]] %>% filter(adj.p.value<0.05)) > 10){
    p_type="adj.p.value"} else {
      p_type="p.value"}
sig_knowns <- nrow(Client_Data_Download[["report_results"]] %>% filter(adj.p.value<0.05) %>% filter(ID_confidence=="High")) 
} 
if (test_type =="t.test"){
  if(nrow(Client_Data_Download[["report_results"]] %>% filter(adj.p.value<0.05)) > 10){
    p_type="adj.p.value"} else {
      p_type="p.value"}
  sig_knowns <- nrow(Client_Data_Download[["report_results"]] %>% filter(!!sym(p_type)<0.05) %>% filter(ID_confidence=="High"))
}
if (test_type=="nostats"){
  p_type="log2FC"
  sig_knowns <- nrow(Client_Data_Download[["report_results"]] %>% filter(abs(log2FC)>0.58) %>% filter(ID_confidence=="High"))
}
if(test_type == "anova"){
if(nrow(Client_Data_Download[["report_results"]] %>% filter(adj.p.value<0.05)) > 10){
    p_type="adj.p.value"} else {
      p_type="adj.p.value"} #anova with emmeans will only have adj p value bc it's adjusted for multiple contrasts
sig_knowns <- nrow(Client_Data_Download[["report_results"]] %>% filter(adj.p.value<0.05) %>% filter(ID_confidence=="High"))
} 
```

```{r,eval=TRUE}
#If we need to remove dummy prefixes for contrast ordering
# Function to clean column names and data within the data frame
clean_data <- function(df) {
  colnames(df) <- gsub("Zref_", "", colnames(df))
  df[] <- lapply(df, function(x) {
    if (is.character(x)) {
      return(gsub("Zref_", "", x))
    } else if (is.factor(x)) {
      levels(x) <- gsub("Zref_", "", levels(x))
      return(x)
    } else {
      return(x)
    }
  })
  return(df)
}

# Apply the function to each element in the list if it's a data frame
for (i in 1:length(Client_Data_Download)) {
  if (is.data.frame(Client_Data_Download[[i]])) {
    Client_Data_Download[[i]] <- clean_data(Client_Data_Download[[i]])
  }
}

#Set a class order
if(length(class_order)<1){
class_order <- levels(as.factor(Client_Data_Download[["metadata"]]$Class))
}
```

# Project Summary

PI: `r PI`

Institution: `r Institution`

Department: `r Department`

Study Contact: `r StudyContact`

Project: `r Project`

Study Title: `r StudyTitle`

Hypothesis/Goal:  `r Hypothesis`

Study Summary: `r StudySummary`

## Sample Information</span>

`r if(subset) {paste("This report is an analysis of", nrow(Client_Data_Download$metadata %>% filter(!str_detect(Sample.name, "Pool"))), SampleType, "as shown below. Classes with 0 samples were included in normalization but omitted from statistical analysis.")}`

`r if (!subset) {paste("The PI provided", nrow(Client_Data_Download$metadata %>% filter(!str_detect(Sample.name, "Pool"))), SampleType)}`

```{r}
datatable(data.frame(table(Client_Data_Download$metadata$Class)), 
          colnames = c(ind_var, "N"),
          options = list(
            dom = 't',   # Show only the table
            paging = FALSE,   # Disable pagination
            searching = FALSE,   # Disable search bar
            ordering = FALSE# Disable column sorting
          )
)
```

## Download sample and compound metadata, processed and normalized peak intensities, and statistical test results

The results of statistical tests to identify changed metabolites are provided. In addition, we also include processed (feature-filtered and missing data imputed), and normalized metabolomic intensity datasets. Please review the "Read Me" sheet included in the download for a detailed explanations of variables.

```{r,eval=FALSE}
#If we need to manually change annotation of a compound
#columns_to_modify <- c("KEGG","CAS.ID", "HMDB.ID","Lab.ID", "Adduct", "mz.error", "mz.match.score", "RT.error", "RT.match.score", "CE", "SS", "Total.score", "Database")
columns_to_modify <- c("KEGG","CAS.ID","Lab.ID", "Adduct", "mz.error", "mz.match.score", "Total.score", "Database")
for (i in c(1,7:9)){

Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
mutate(Level = ifelse(compound == "CO2" & row.ID == "1536", "", Level))

Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
mutate_at(vars(columns_to_modify), ~ ifelse(compound == "CO2" & row.ID == "1536", NA, .))

Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
mutate(compound = ifelse(compound == "CO2" & row.ID == "1536", paste(mz,rt,sep="_"), compound))
}
```

```{r,eval=TRUE}
#If we need to manually remove a compound
#columns_to_modify <- c("KEGG","CAS.ID", "HMDB.ID","Lab.ID", "Adduct", "mz.error", "mz.match.score", "RT.error", "RT.match.score", "CE", "SS", "Total.score", "Database")
for (i in c(1:length(Client_Data_Download))){
  tryCatch({
    Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
      dplyr::filter(!compound %in% drop_compounds)
  }, error = function(e) {
    # Handle the error (in this case, do nothing)
  })
}
```

```{r}
for (i in c(1:length(Client_Data_Download))){
  if("contrast.x" %in% colnames(Client_Data_Download[[i]])){
Client_Data_Download[[i]] <- Client_Data_Download[[i]] %>% 
dplyr::rename(contrast=contrast.x)
  }
}
```

```{r,eval=FALSE}
#version update 2.1 this was removing metadata rows instead of moving to the top ...now just don't run it
#Put the metadata rows at the top of counts matrices
for (i in c(1:length(Client_Data_Download))){
if("data.frame" %in% class(Client_Data_Download[[i]])){
Client_Data_Download[[i]] <- Client_Data_Download[[i]][c(which(is.na(Client_Data_Download[[i]][, 1]))[-1], which(!is.na(Client_Data_Download[[i]][, 1]))), ]
}
}
```

```{r}
contrasts <- levels(as.factor(Client_Data_Download[["report_results"]]$contrast))
```

```{r,echo=FALSE,warning=FALSE,message=FALSE}
#Remove the last two because they're the plots
Client_Data_Download_out <- Client_Data_Download
if(test_type=="t.test"){
  if(subset){
    Client_Data_Download_out[["README"]] <- read.csv("../InputFiles/ttest.batchCorrect.README.csv")}else{
    Client_Data_Download_out[["README"]] <- read.csv("../InputFiles/ttest.README.csv")
  }
}
if(test_type %in% c("anova", "lmm","repeated_measures_anova","lme")){
Client_Data_Download_out[["README"]] <- read.csv("../InputFiles/ANOVA.emmeans.README.csv")
}
if(test_type == "nostats"){
Client_Data_Download_out[["README"]] <- read.csv("../InputFiles/ttest.README.csv") #Change this
}

# Modify the README data frame
Client_Data_Download_out[["README"]] <- Client_Data_Download_out[["README"]] %>%
  mutate(
    Field = ifelse(Field == "Level", "ID_confidence", Field),
    Description = gsub("\\b1\\b", "High", Description),
    Description = gsub("\\b3\\b", "Low", Description)
  )


Client_Data_Download_out <- c(Client_Data_Download_out["README"],Client_Data_Download_out[1:length(Client_Data_Download_out)-1])
Client_Data_Download_out[["report_results"]] <- Client_Data_Download_out[["report_results"]] %>% filter(contrast %in% contrasts)
Client_Data_Download_out <- Client_Data_Download_out[!grepl("View",names(Client_Data_Download_out))] 
Client_Data_Download_out %>% 
  download_this(
    output_name = "SECIM_Metabolomics",
    output_extension = ".xlsx",
    button_label = "Download metabolomics data and results",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save"
  )
#Client_Data_Download[["report_results"]] <- Client_Data_Download[["report_results"]] %>% dplyr::rename("p.value"="adj.p.value")
```

```{r}
# Function to check if an element is a data frame and apply type.convert
convert_if_dataframe <- function(df) {
  if (is.data.frame(df)) {
    return(type.convert(df, as.is = TRUE))
  } else {
    return(df)
  }
}

# Apply the function to each element in the list
for (i in seq_along(Client_Data_Download)) {
  tryCatch({
    Client_Data_Download[[i]] <- convert_if_dataframe(Client_Data_Download[[i]])
  }, error = function(e) {
    # Handle any errors (optional)
    message("Error in type conversion for element ", i, ": ", e)
  })
}

```

## Global metabolomics profiling</span>

Global metabolomics profiling was performed on a Thermo Q-Exactive Orbitrap mass spectrometer with Dionex UHPLC and autosamples. All samples were normalized by total protein content prior to extraction. Samples were analyzed in positive and negative heated electrospray ionization with a mass resolution of 35,000 at m/z 200 as separate injections. Separation was achieved on an ACE 18-pfp 100 x 2.1 mm, 2 µm column with mobile phase A as 0.1% formic acid in water and mobile phase B as acetonitrile. This is a polar embedded stationary phase that provides comprehensive coverage, but does have some limitation is the coverage of very polar species. The flow rate was 350 µL/min with a column temperature of 25°C. 4 µL was injected for negative ions and 2 µL for positive ions.

## Raw data generation</span>

Metabolites were detected in both positive and negative ion modes as some metabolites are better ionized in one mode or the other. 

MZmine (freeware) was used to identify features, deisotope, and align features. All adducts and complexes were identified and removed from the data set. The mass and retention time data was searched against our internal metabolite library, and known metabolites were mapped to KEGG IDs. 

# Quality control and data transformation</span>

`r if(filter_method=="ICC"){"Blank feature filtering was performed based on a intraclass correlation coefficient (ICC) (Schiffman, C. et al. 2019) as implemented in the R package qmtools (Joo J and Himes B 2022)."}`

`r if(filter_method=="BFF"){"Blank feature filtering was performed by removing features for which samples' inner-quartile range was less than the blanks' lower limit of quantitation."}`

`r if(filter_method=="IQR"){"Blank feature filtering was performed using inner-quartile range filtering as implemented in the R package MetaboAnalystR (https://github.com/xia-lab/MetaboAnalystR)"}`

Missing data were imputed by k-nearest neighbor imputation as implemented in the R package MetaboAnalystR (https://github.com/xia-lab/MetaboAnalystR).

## Normalization Method

`r if(norm_method=="vst"){"Peak intensities were normalized using the variance stabilizing transformation using the R package MetaboDiff (Mock et al. 2018)."}`

`r if(norm_method=="median"){"Peak intensities were normalized using the median method of normalization as implemented the R package MSPrep (McGrath M et al. 2022)."}`

`r if(norm_method=="quantile"){"Peak intensities were normalized using the quantile method of normalization as implemented the R package MSPrep (McGrath M et al. 2022)."}`

`r if (norm_method=="MetaboanalystR"){rowNorm <- rowNorm; transNorm <- transNorm; scaleNorm <- scaleNorm;rowNormText <- switch(rowNorm, "QuantileNorm" = "Quantile normalization", "CompNorm" = "Normalization by a reference feature", "SumNorm" = "Normalization to constant sum", "MedianNorm" = "Normalization to sample median", "SpecNorm" = "Normalization by a sample-specific factor", "none" = NULL); transNormText <- switch(transNorm, "LogNorm" = "log (base 10) transformation", "CrNorm" = "cubic root transformation", "none" = NULL); scaleNormText <- switch(scaleNorm, "MeanCenter" = "mean centering", "AutoNorm" = "autoscaling", "ParetoNorm" = "Pareto scaling", "RangeNorm" = "range scaling", "none" = NULL); normalizationText <- paste(if (!is.null(rowNormText)) paste("Peak intensities were normalized sample-wise using", rowNormText) else NULL, if (!is.null(transNormText)) paste("followed by", transNormText) else NULL, if (!is.null(scaleNormText)) paste("and", scaleNormText) else NULL, "as implemented in the R package MetaboAnalystR (https://github.com/xia-lab/MetaboAnalystR).", "Please note that this method of normalization results in negative values and these are expected in your normalized dataset."); normalizationText}`

`r if(batch_correct=="ComBat"){"Peak intensities were batch-corrected using the ComBat function from the R package sva (Leek JT et al. 2022) "}`

`r if(batch_correct=="limma"){"Peak intensities were batch-corrected using the removeBatchEffect() function from the R package limma (Ritchie ME et al. 2015) "}`

\n Visualizations to assess the effect of normalization are provided below.

##  Normalization Result (Positive ionization mode) </span>

```{r,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,fig.dim = c(4, 4)}
grid.arrange(Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[1]],Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[2]],Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[3]],Client_Data_Download[["Pos.FeatureView"]][["grobs"]][[4]],
             top = textGrob("Feature View",gp=gpar(fontsize=20,font=3)))
grid.arrange(Client_Data_Download[["Pos.SampleView"]][["grobs"]][[1]],Client_Data_Download[["Pos.SampleView"]][["grobs"]][[2]],Client_Data_Download[["Pos.SampleView"]][["grobs"]][[3]],Client_Data_Download[["Pos.SampleView"]][["grobs"]][[4]],
              top = textGrob("Sample View",gp=gpar(fontsize=20,font=3)))
```

##  Normalization Result (Negative ionization mode) </span>

```{r,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,fig.dim = c(4, 4)}
grid.arrange(Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[1]],Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[2]],Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[3]],Client_Data_Download[["Neg.FeatureView"]][["grobs"]][[4]])
grid.arrange(Client_Data_Download[["Neg.SampleView"]][["grobs"]][[1]],Client_Data_Download[["Neg.SampleView"]][["grobs"]][[2]],Client_Data_Download[["Neg.SampleView"]][["grobs"]][[3]],Client_Data_Download[["Neg.SampleView"]][["grobs"]][[4]])
```

# Statistical analysis</span>

```{r}
if(!test_type=="nostats"){
html_text <- "Multivariate and univariate statistical analysis were performed to assess clustering of samples based on metabolomic profiles and to identify metabolites with changes in abundance between groups or biological conditions.<br><br>"
}else{
html_text <- "Multivariate statistical analysis and fold-change analysis were performed to assess clustering of samples based on metabolomic profiles and to identify metabolites with changes in abundance between groups or biological conditions.<br><br>"
}
htmltools::HTML(html_text)
```

Following analysis of all compounds detected in positive and negative ionization modes independently, the list of compounds were combined between negative and positive ionization modes and reduced to a single representative compound per likely metabolite based on p-value (lowest p-value compound retrained).

## PCA (multivariate analaysis)</span>

Principal component analysis of untargeted metabolomics data. Two-dimensional PCA score plots reveal possible separation in metabolite profiles related to variables of interest. Ellipses are calculated using the R package car (Fox J. and Weisberg S. 2019) and ~1 Std dev.

`r ifelse(subset, "**PCA of all study samples that were included in batch-correction and normalization prior to statistical analysis, colored by batch.**", "")`

```{r}
if(batch_correct %in% c("limma","ComBat")){
library(plotly)
library(RColorBrewer)
library(car)

plot_pca <- function(data, show_legend = TRUE) {
  PCA_DATA <- t(rbind(data[["Neg"]][,3:(num_total_samples+2)],
                      data[["Pos"]][-(1:num_of_metadata-1),3:(num_total_samples+2)]))
  
  numsonly <- data.frame(PCA_DATA[,-c(1:num_of_metadata-1)])
  numsonly <- data.frame(lapply(numsonly, as.numeric))
  pca_res <- prcomp(numsonly, center = TRUE, scale. = FALSE, rank. = 2)
  
  scores <- pca_res$x
  colors <- RColorBrewer::brewer.pal(num_batches, "Set1")
  
  plot_ellipse_function <- function(target) {
    target_data <- as.data.frame(scores[PCA_DATA[,(num_of_metadata-1)] == target, 1:2])
    target_color <- colors[which(unique(PCA_DATA[,(num_of_metadata-1)]) == target)]
    
    ellipse_coords <- car::dataEllipse(target_data$PC1, target_data$PC2, 
                                       levels = 0.68, 
                                       plot.points = FALSE, add = TRUE, draw = FALSE)
    
    fig <<- fig %>% 
      add_polygons(x = ellipse_coords[,1], y = ellipse_coords[,2],
                   line = list(color = target_color, dash = "dot"),
                   fillcolor = target_color, opacity = 0.3,
                   showlegend = FALSE,
                   hoverinfo = "skip")
  }
  
  plot_points_function <- function(target) {
    target_data <- as.data.frame(scores[PCA_DATA[,(num_of_metadata-1)] == target, 1:2])
    rownames(target_data) <- rownames(PCA_DATA)[PCA_DATA[,(num_of_metadata-1)] == target]
    target_color <- colors[which(unique(PCA_DATA[,(num_of_metadata-1)]) == target)]
    
    text_data <- as.character(rownames(target_data))
    PC1 <- as.numeric(target_data$PC1)
    PC2 <- as.numeric(target_data$PC2)
    
    fig <<- fig %>% 
      add_trace(data = target_data,
                x = ~PC1, y = ~PC2, 
                type = "scatter",
                mode = "markers",
                name = target,
                marker = list(color = target_color),
                text = ~text_data,
                hoverinfo = "text",
                showlegend = show_legend)
  }
  
  fig <- plot_ly()
  
  invisible(lapply(unique(PCA_DATA[,(num_of_metadata-1)]), plot_ellipse_function))
  invisible(lapply(unique(PCA_DATA[,(num_of_metadata-1)]), plot_points_function))
  
  fig <- fig %>% layout(xaxis = list(title = 'PC1'), yaxis = list(title = 'PC2'))
  return(fig)
}

pre_data <- list(
  Neg = Client_Data_Download_out[["Neg.processed.data"]],
  Pos = Client_Data_Download_out[["Pos.processed.data"]]
)
if(subset==TRUE){
post_data <- list(
  Neg = Client_Data_Download_out[["Neg.total.normalized.data"]],
  Pos = Client_Data_Download_out[["Pos.total.normalized.data"]]
)
} else {
  post_data <- list(
  Neg = Client_Data_Download_out[["Neg.normalized.data"]],
  Pos = Client_Data_Download_out[["Pos.normalized.data"]]
)
}

pre_plot <- plot_pca(pre_data, show_legend = TRUE)
post_plot <- plot_pca(post_data, show_legend = FALSE)

# Combine the two plots side by side without sharing the Y axis
combined_plot <- subplot(pre_plot, post_plot, nrows = 1, shareY = FALSE)

annotations = list( 
  list( 
    x = 0.2,  
    y = 1.0,  
    text = "PCA of samples by batch before batch correction",  
    xref = "paper",  
    yref = "paper",  
    xanchor = "center",  
    yanchor = "bottom",  
    showarrow = FALSE 
  ),  
  list( 
    x = 0.8,  
    y = 1,  
    text = "PCA of samples by batch after batch correction",  
    xref = "paper",  
    yref = "paper",  
    xanchor = "center",  
    yanchor = "bottom",  
    showarrow = FALSE
  ))

combined_plot <- combined_plot %>%layout(annotations = annotations) 
combined_plot
}
```

`r ifelse(subset, "**PCA of samples included in statistical analysis, colored by group.**", "")`


```{r}
#We want to remove the metadata row(s) and all non sample cols from Client_Data_Download
 PCA_DATA <- t(rbind(Client_Data_Download_out[["Neg.normalized.data"]][,3:(num_samples+2)],
 Client_Data_Download_out[["Pos.normalized.data"]][-(1:num_of_metadata-1),3:(num_samples+2)]))

numsonly <- data.frame(PCA_DATA[,-c(1:num_of_metadata-1)])
#Make numeric

numsonly <- data.frame(lapply(numsonly,as.numeric))
pca_res <- prcomp(numsonly, center = TRUE, scale. = FALSE,rank. = 2) #The old version used the defaults

scores <- pca_res$x

colors <- RColorBrewer::brewer.pal(num_groups, "Set1")
# Function to plot ellipse for each target
plot_ellipse_function <- function(target) {
  target_data <- as.data.frame(scores[PCA_DATA[,1] == target, 1:2])
  target_color <- colors[which(unique(PCA_DATA[,1]) == target)]
  
  # Ellipse
  ellipse_coords <- car::dataEllipse(target_data$PC1, target_data$PC2, 
                                     levels = 0.68, # roughly corresponds to 1 std dev
                                     plot.points = FALSE, add = TRUE, draw = FALSE)
  
  fig <<- fig %>% 
    add_polygons(x = ellipse_coords[,1], y = ellipse_coords[,2],
                 line = list(color = target_color, dash = "dot"),
                 fillcolor = target_color, opacity = 0.3,
                 showlegend = F,
                 hoverinfo = "skip")  # this tells plotly not to show any hover information for the ellipses
}

# Function to plot points for each target
plot_points_function <- function(target) {
  target_data <- as.data.frame(scores[PCA_DATA[,1] == target, 1:2])
  rownames(target_data) <- rownames(PCA_DATA)[PCA_DATA[,1]==target]
  target_color <- colors[which(unique(PCA_DATA[,1]) == target)]
  
  text_data <- as.character(rownames(target_data))
  PC1 <- as.numeric(target_data$PC1)
  PC2 <- as.numeric(target_data$PC2)

  # Scatter points
  fig <<- fig %>% 
    add_trace(data = target_data,
              x = ~PC1, y = ~PC2, 
              type = "scatter",
              mode = "markers",
              name = target,
              marker = list(color = target_color),
              text = ~text_data,
              hoverinfo = "text")  # this tells plotly to display the text when hovering
}

fig <- plot_ly()

# First loop: Plot all ellipses
invisible(lapply(unique(PCA_DATA[,1]), plot_ellipse_function))

# Second loop: Plot all points
invisible(lapply(unique(PCA_DATA[,1]), plot_points_function))

fig
```

## Univariate analysis </span>

`r if(test_type=="anova"){"ANOVA was performed using the R package stats (R Core Team 2023) to determine whether there was a significant effect of variable Class on metabolite peak intensity, and post-hoc pairwise comparisons were performed using Estimated Marginal Means (aka Least-Squares Means) as implemented in the R package emmeans (R.V. Lenth 2023). Adjusted p-values are adjusted for multiple pairwise comparison testing, not testing of multiple metabolites."}`

`r if(test_type=="repeated_measures_anova"){"A repeated-measures ANOVA was performed using the R package stats (R Core Team 2023) to determine whether there was a significant effect of variable Class on metabolite peak intensity. The anova formula was Metabolite~Class+Error(ID) and post-hoc pairwise comparisons were performed using Estimated Marginal Means (aka Least-Squares Means) as implemented in the R package emmeans (R.V. Lenth 2023). Adjusted p-values are adjusted for multiple pairwise comparison testing, not testing of multiple metabolites."}`

```{r, echo=FALSE, results='asis'}
if(test_type == "lmm") {
  cat("A linear mixed model was performed using the R package stats (R Core Team 2023) to determine whether there was a significant effect of variable Class on metabolite peak intensity. The model was ", lm_model, ". Post-hoc pairwise comparisons were performed using Estimated Marginal Means (aka Least-Squares Means) as implemented in the R package emmeans (R.V. Lenth 2023). Adjusted p-values are corrected using the FDR method of p-value correction.", sep="")
}
```

`r if(test_type == "t.test") {
  if(paired == TRUE) {
    paste0("For each compound, a paired t-test was performed using the R package stats (R Core Team 2023) to test the null hypothesis that the mean intensity for group one (e.g. before) = the mean intensity for group two (e.g. after). Adjusted p-values are corrected using the FDR method of p-value correction. If fewer than ten significantly changed metabolites were identified based on adjusted p-values, uncorrected p-values are reported.",
    "<strong>If fewer than ten significantly changed metabolites were identified based on adjusted p-values, uncorrected p-values are reported.</strong>")
  } else {
    paste0("For each compound, a Welch's t-test was performed using the R package stats (R Core Team 2023) to test the null hypothesis that the mean intensity for group one = the mean intensity for group two. Adjusted p-values are corrected using the FDR method of p-value correction. ", 
    "<strong>If fewer than ten significantly changed metabolites were identified based on adjusted p-values, uncorrected p-values are reported.</strong>")
  }
}`


`r if(test_type=="nostats"){"For each compound, no statistical analysis was performed. Instead, a fold-change analysis was performed"}`

```{r,eval=FALSE,order_contrasts}
contrasts <- contrasts[c(1,2,5,6)]
```

```{r,eval=TRUE,filter}
#Make significant metabolite list (perform any filtering needed including significance in one contrasts but not in another, etc.)
#For each contrast, there are significant peaks
sig_peaks=list()
sig_peaks_rowID=list()
if(p_type=="adj.p.value"){
for(i in 1:length(contrasts)){
sig_peaks[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(adj.p.value<0.05) %>% dplyr::select(compound) %>% unlist()
sig_peaks_rowID[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(adj.p.value<0.05) %>% dplyr::select(row.ID) %>% unlist()
}
names(sig_peaks) <- contrasts
} 
if (p_type=="p.value"){
  for(i in 1:length(contrasts)){
    sig_peaks[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(p.value<0.05) %>%   dplyr::select(compound) %>% unlist()
    sig_peaks_rowID[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(p.value<0.05) %>%   dplyr::select(row.ID) %>% unlist()
  }
  names(sig_peaks) <- contrasts
  names(sig_peaks_rowID) <- contrasts
}
if (p_type=="log2FC"){
  for(i in 1:length(contrasts)){
    sig_peaks[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(abs(log2FC)>1.5) %>%   dplyr::select(compound) %>% unlist()
    sig_peaks_rowID[[i]] <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% filter(abs(log2FC)>1.5)  %>%   dplyr::select(row.ID) %>% unlist()
    }
  names(sig_peaks) <- contrasts
  names(sig_peaks_rowID) <- contrasts
}
```

```{r,eval=FALSE}
#For each contrast, there can be a list of peaks to drop
#PER REPORT custom code to filter out peaks from a given contrast
#Report_Generator.v2: This has not been updated in a few versions, if it is needed check that it works 
drop_peaks <- list()
drop_rowID <- list()
for(i in 1:length(contrasts)){
drop_peaks[[i]] <- c("")}
drop_peaks[[3]] <- Client_Data_Download[["report_results"]]  %>% filter(contrast==contrasts[[6]]) %>% filter(p.value<0.05) %>% dplyr::select(compound) %>% unlist() 
drop_rowID[[3]] <- Client_Data_Download[["report_results"]]  %>% filter(contrast==contrasts[[6]]) %>% filter(p.value<0.05) %>% dplyr::select(rowID) %>% unlist() 

#For each contrast, by removing the drop peaks we obtain a focal peaks list
for(i in 1:length(contrasts)){
sig_peaks[[i]] <- sig_peaks[[i]][!sig_peaks[[i]] %in% drop_peaks[[i]]]
sig_peaks_rowID[[i]] <- sig_peaks_rowID[[i]][!sig_peaks_rowID[[i]] %in% drop_rowID[[i]]]

}
names(sig_peaks) <- contrasts
names(sig_peaks_rowID) <- contrasts

```

```{r}
#Make all of this into an R code block so a for loop can be used
if(p_type %in% c("p.value","adj.p.value")){
  for (i in 1:length(contrasts)){
    print(paste(length(sig_peaks[[i]]), "metabolites were significantly changed (",p_type,"< 0.05) between",str_split(contrasts[[i]],"-")[[1]][[1]], "and",str_split(contrasts[[i]],"-")[[1]][[2]],sep=" "))
    }
}
if(p_type=="log2FC"){
  for (i in 1:length(contrasts)){
    print(paste(length(sig_peaks[[i]]), "metabolites were changed (",p_type,"> 1.5) between",str_split(contrasts[[i]],"-")[[1]][[1]], "and",str_split(contrasts[[i]],"-")[[1]][[2]],sep=" "))
    }  
}
```

## Compound identification </span>

Unknown compounds (those unidentified by our internal metabolite library) were assigned low-confidence metabolite names and KEGG IDs based on mass and the HMDB database as implemented in the R package metid (Shen X 2022).

The annotation of these compounds is assigned a confidence value (ID_confidence) of "Low" in downloadable tables and in the report.

Compounds identified using our internal library are assigned a confidence value of "High".

Compounds that could not be identified via either method are annotated using their m/z_RT values and the ID_confidence is blank.

```{r}
#Make all of this into an R code block so a for loop can be used
if(p_type %in% c("p.value","adj.p.value")){
  for (i in 1:length(contrasts)){
    print(paste(nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(compound %in% sig_peaks[[i]] & ID_confidence == "High"))
, "significantly changed metabolites(",p_type,"< 0.05) between",str_split(contrasts[[i]],"-")[[1]][[1]], "and",str_split(contrasts[[i]],"-")[[1]][[2]]," were annotated with high confidence",sep=" "))
    }
}
if(p_type=="log2FC"){
  for (i in 1:length(contrasts)){
    print(paste(nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(compound %in% sig_peaks[[i]] & ID_confidence=="High"))
, "significantly changed metabolites  (",p_type,"> 1.5) between",str_split(contrasts[[i]],"-")[[1]][[1]], "and",str_split(contrasts[[i]],"-")[[1]][[2]],"were annotated with high confidence",sep=" "))
    }  
}
```

**For visualizations, compounds are sorted by confidence and then by significance so that compounds with high-confidence IDs are shown first**

```{r}
if(test_type == "nostats"){
  html_text <- "<h2>Table of changed metabolites </h2><br>"
} else {
  html_text <-"<h2>Table of significantly changed metabolites </h2><br>"
}
htmltools::HTML(html_text)
```

`r if(test_type=="nostats"){"Table of metabolites filtered as described above (log2FC > 1.5)."}`

`r if(p_type=="p.value"){"Table of significantly changed metabolites for overall effect of independent variable and for pairwise-contrasts filtered as described above (p-value < 0.05)."}`

`r if(p_type=="adj.p.value"){"Table of significantly changed metabolites for overall effect of independent variable and for pairwise-contrasts filtered as described above (adjusted p-value < 0.05)."}`

```{r}
if (test_type == "nostats") {
  html_text <- "To view results for a test of interest, click the arrow at the top of the contrast column to sort by contrast or use the search bar to search for a contrast. To see what metabolites were changed for more than one contrast, sort by metabolite and see how many contrasts were significant for each metabolite. (Tip: Reverse sorting by Metabolite will display known metabolites first.)<br><br>"
} else {
  html_text <- "To view results for a test of interest, click the arrow at the top of the contrast column to sort by contrast or use the search bar to search for a contrast. To see what metabolites were significantly changed for more than one test, sort by metabolite and see how many contrasts were significant for each metabolite. (Tip: Reverse sorting by Metabolite will display known metabolites first.)<br><br>"
}
htmltools::HTML(html_text)
```

```{r,warn=FALSE}
if(p_type == "p.value"){
  dt <- datatable(Client_Data_Download[["report_results"]] %>%
              filter(p.value < 0.05) %>%
              dplyr::select(c(compound, p.value, ID_confidence, contrast, contains("FC"))) %>%
              mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", "")), 
                     across(where(is.numeric), round, 5)) %>%
              arrange(ID_confidence, p.value), 
            caption = 'Table of significantly changed metabolites for (p-value < 0.05)')
    dt %>% formatRound(columns = c("p.value", "FC", "log2FC"), digits = 4)

}

if(p_type == "adj.p.value"){
  dt <- datatable(Client_Data_Download[["report_results"]] %>%
              filter(adj.p.value < 0.05) %>%
              dplyr::select(c(compound, adj.p.value, ID_confidence, contrast, contains("FC"))) %>%
              mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", "")), 
                     across(where(is.numeric), round, 5)) %>%
              arrange(ID_confidence, adj.p.value), 
            caption = 'Table of significantly changed metabolites for (adjusted p-value < 0.05)')
  dt %>% formatRound(columns = c("adj.p.value", "FC", "log2FC"), digits = 4)
}

if(p_type == "log2FC"){
  dt <- datatable(Client_Data_Download[["report_results"]] %>%
              filter(abs(log2FC) > 1.5) %>%
              dplyr::select(c(compound, ID_confidence, contrast, contains("FC"))) %>%
              mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", "")), 
                     across(where(is.numeric), round, 5)) %>%
              arrange(ID_confidence, log2FC), 
            caption = 'Table of changed metabolites (log2FC > 1.5)')
    dt %>% formatRound(columns = c("FC", "log2FC"), digits = 4)

}
```

## Metabolite set enrichment analysis (MSEA) 

**MSEA was performed for the list of significantly changed metabolites using Metaboanalyst R and the SMPDB (Small Molecule Pathway Database) database.**

Name matching between the SECIM library database and the Metaboanalyst R MSEA database is imperfect and some significantly changed compounds may have been ommitted from the MSEA. Only metabolites identified with high confidence are input in the MSEA.

Enrichment Ratio is computed by Hits / Expected, where hits = observed hits; expected = expected hits (see the Table below)

```{r, echo=FALSE, results='asis'}
result <- tryCatch({
  capture.output({
    source("/blue/timgarrett/hkates/SECIM_Reporting/R/MSEA.smpdb.R")
  }, type = "output")
  NULL  # Successfully executed, no special message to print
}, error = function(e) {
  "No overlap between significantly enriched compound IDs and KEGG database"  # Custom error message
})

if (!is.null(result)) {
  cat(result)
}
```

```{r, echo=FALSE, results='asis'}
tryCatch({
  image_path <- paste0("/blue/timgarrett/hkates/SECIM_Reporting/", client, "MSEA.", "pngdpi300.png")
  
  # Attempt to verify if the file exists before trying to display it
  if (!file.exists(image_path)) {
    stop("Image file does not exist.")
  }
  
  cat("![MSEA results for significantly changed compounds](", image_path, ")", sep="")
}, error = function(e) {
  # Print a custom message or handle the error differently
  cat("No overlap between significantly enriched compound IDs and KEGG database or image could not be displayed.")
})
```

```{r}
# Try to display the table with a tryCatch block
tryCatch({
  datatable(result_tbl)
}, error = function(e) {
  # Do nothing on error
})
```

# Visualizations of Changed Metabolites

All plots below can be zoomed, selected, and downloaded individually (and/or as modified) using the toolbar on the top right of the figure (will appear when you hover your mouse). Hover over plot points to view underlying data.

## Barplots of changed metabolites by metabolite KEGG class

**If your study/contrast yielded > 20 significantly changed compounds with high-confidence IDs, only high-confidence IDs are included as input compounds.**

```{r}
if(test_type == "nostats"){
  if(sig_knowns<20){
  html_text <- "Metabolites with >1.5 log2FC change are shown by metabolite class. </span><br><br>"}else{
    html_text <- "High ID_confidence Metabolites with >1.5 log2FC change are shown by metabolite class. </span><br><br>"
  }
} else {
  if(sig_knowns<20){
  html_text <- paste0("Metabolites with significant changes (",p_type,"<0.05) are shown by metabolite class.</span><br><br>")}else{
     html_text <- paste0("High ID_confidence Metabolites with significant changes (",p_type,"<0.05) are shown by metabolite class. </span><br><br>")
  }
}
htmltools::HTML(html_text)
```

```{r}
if(test_type == "nostats"){
  html_text <- "Hover over bars to view changed metabolites for each class. (If a contrast is missing, there were no >1.5 log2FC changed metabolites with KEGG IDs for that contrast) </span><br>"
} else {
  html_text <- "Hover over bars to view significantly changed metabolites for each class. (If a contrast is missing, there were no significantly changed metabolites with KEGG IDs for that contrast) </span><br>"
}
htmltools::HTML(html_text)
```

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.dim = c(30, 30),eval=TRUE}
if(sig_knowns<20){
barplotlist = list()
  for (i in 1:length(contrasts)){
    
##Make a min and max for a contrast's barplot fig
#make an empty dataframe
barplotminmax.vector <- list()
for (classvar in levels(as.factor(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::select(Class) %>% unlist()))){
  #the class
barplotminmax.vector <- c(barplotminmax.vector,
#The number of increases
nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0)),
  #The number of decreases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]]&log2FC< 0)))
}
##

#Summarize by class
#make an empty dataframe
bar.df <- data.frame(matrix(ncol = 5, nrow = 0))
for (classvar in levels(as.factor(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::select(Class) %>% unlist()))){
  if(
    #The number of increases
    (nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0))+ #plus
  #The number of decreases
nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC< 0)))>0){ #is greater than 0, then 
  #the class
barplotvector <- c(classvar,
#The number of increases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0)),
  #The number of decreases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC< 0)),
  #The metabolites that increased
gsub("(?m),\\s(?!\\d)|,\\s*$", "\\1\n", toString(t(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::filter(Class==classvar) %>% filter(compound %in% sig_peaks[[i]]) %>% filter(log2FC> 0)%>% dplyr::select(c(compound,ID_confidence)))),perl=TRUE),
#The metabolites that decreased
gsub("(?m),\\s(?!\\d)|,\\s*$", "\\1\n", toString(t(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::filter(Class==classvar) %>% filter(compound %in% sig_peaks[[i]]) %>% filter(log2FC < 0)%>% dplyr::select(c(compound,ID_confidence)))),perl=TRUE))
bar.df<<-rbind(barplotvector,bar.df)
}
}
#Make the colnames the first row
colnames(bar.df) <- bar.df[1,]
#Add colnames
if(test_type=="nostats"){
  colnames(bar.df) <- c("Class","Increases","Decreases","Increase_Text","Decrease_Text")
  if(sum(as.numeric(bar.df$Increases)+as.numeric(bar.df$Decreases))>0){
fig <- plot_ly()
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Decreases),
    hovertemplate = bar.df$Decrease_Text,
    base = -as.numeric(bar.df$Decreases),
    marker = list(
      color = 'red'
    ),
    name = paste("Decreased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]))
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Increases),
    base = 0,
    hovertemplate = bar.df$Increase_Text,
    marker = list(
      color = 'blue'
    ),
     name = paste("Increased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2])
  )

fig <- fig %>% layout(title = paste(" >1.5 log2FC changes by metabolite class\n(",contrasts[[i]],")"),
         xaxis = list(title = ""),
         #It would be better to set the range to min,max across all contrasts,
         #But that information is not available when each plot is drawn.
         yaxis = list(title = "",tick0=0, dtick=1,range = list(-max(data.frame(barplotminmax.vector)),max(data.frame(barplotminmax.vector)))),margin = list(l = 75, t = 150))
fig %>% layout(title="TEST")
barplotlist[[i]] = ggplotly(fig) 
} else{
print("No metabolite classes with >1.5 log2FC changes")
}
  }else{
colnames(bar.df) <- c("Class","Significant_Increases","Significant_Decreases","Increase_Text","Decrease_Text")
if(sum(as.numeric(bar.df$Significant_Increases)+as.numeric(bar.df$Significant_Decreases))>0){
fig <- plot_ly()
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Significant_Decreases),
    hovertemplate = bar.df$Decrease_Text,
    base = -as.numeric(bar.df$Significant_Decreases),
    marker = list(
      color = 'red'
    ),
    name = paste("Decreased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]))
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Significant_Increases),
    base = 0,
    hovertemplate = bar.df$Increase_Text,
    marker = list(
      color = 'blue'
    ),
     name = paste("Increased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2])
  )

fig <- fig %>% layout(title = paste("Significant changes by metabolite class\n(",contrasts[[i]],")"),
         xaxis = list(title = ""),
         #It would be better to set the range to min,max across all contrasts,
         #But that information is not available when each plot is drawn.
         yaxis = list(title = "",tick0=0, dtick=1,range = list(-max(data.frame(barplotminmax.vector)),max(data.frame(barplotminmax.vector)))),margin = list(l = 75, t = 150),width=900,height=500)
barplotlist[[i]] = ggplotly(fig) 
} else
{
print("No metabolite classes with significant changes")
}
}
  }
htmltools::tagList(setNames(barplotlist, NULL))
} else {
  #If more than 20 significantly changed known compounds
  barplotlist = list()
  for (i in 1:length(contrasts)){
    
##Make a min and max for a contrast's barplot fig
#make an empty dataframe
barplotminmax.vector <- list()
for (classvar in levels(as.factor(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::select(Class) %>% unlist()))){
  #the class
barplotminmax.vector <- c(barplotminmax.vector,
#The number of increases
nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0 & ID_confidence=="High")),
  #The number of decreases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]]&log2FC< 0& ID_confidence=="High")))
}
##

#Summarize by class
#make an empty dataframe
bar.df <- data.frame(matrix(ncol = 5, nrow = 0))
for (classvar in levels(as.factor(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::select(Class) %>% unlist()))){
  if(
    #The number of increases
    (nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0& ID_confidence=="High"))+ #plus
  #The number of decreases
nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC< 0& ID_confidence=="High")))>0){ #is greater than 0, then 
  #the class
barplotvector <- c(classvar,
#The number of increases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC> 0& ID_confidence=="High")),
  #The number of decreases
  nrow(data.frame(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])) %>% dplyr::filter(Class==classvar& compound %in% sig_peaks[[i]] &log2FC< 0& ID_confidence=="High")),
  #The metabolites that increased
gsub("(?m),\\s(?!\\d)|,\\s*$", "\\1\n", toString(t(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::filter(Class==classvar) %>% filter(compound %in% sig_peaks[[i]]) %>% filter(log2FC> 0& ID_confidence=="High")%>% dplyr::select(c(compound,ID_confidence)))),perl=TRUE),
#The metabolites that decreased
gsub("(?m),\\s(?!\\d)|,\\s*$", "\\1\n", toString(t(Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]]) %>% dplyr::filter(Class==classvar) %>% filter(compound %in% sig_peaks[[i]]) %>% filter(log2FC < 0& ID_confidence=="High")%>% dplyr::select(c(compound,ID_confidence)))),perl=TRUE))
bar.df<<-rbind(barplotvector,bar.df)
}
}
#Make the colnames the first row
colnames(bar.df) <- bar.df[1,]
#Add colnames
if(test_type=="nostats"){
  colnames(bar.df) <- c("Class","Increases","Decreases","Increase_Text","Decrease_Text")
  if(sum(as.numeric(bar.df$Increases)+as.numeric(bar.df$Decreases))>0){
fig <- plot_ly()
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Decreases),
    hovertemplate = bar.df$Decrease_Text,
    base = -as.numeric(bar.df$Decreases),
    marker = list(
      color = 'red'
    ),
    name = paste("Decreased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]))
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Increases),
    base = 0,
    hovertemplate = bar.df$Increase_Text,
    marker = list(
      color = 'blue'
    ),
     name = paste("Increased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2])
  )

fig <- fig %>% layout(title = paste(" >1.5 log2FC changes by metabolite class\n(",contrasts[[i]],")"),
         xaxis = list(title = ""),
         #It would be better to set the range to min,max across all contrasts,
         #But that information is not available when each plot is drawn.
         yaxis = list(title = "",tick0=0, dtick=1,range = list(-max(data.frame(barplotminmax.vector)),max(data.frame(barplotminmax.vector)))),margin = list(l = 75, t = 150))
fig %>% layout(title="TEST")
barplotlist[[i]] = ggplotly(fig) 
} else{
print("No metabolite classes with >1.5 log2FC changes")
}
  }else{
colnames(bar.df) <- c("Class","Significant_Increases","Significant_Decreases","Increase_Text","Decrease_Text")
if(sum(as.numeric(bar.df$Significant_Increases)+as.numeric(bar.df$Significant_Decreases))>0){
fig <- plot_ly()
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Significant_Decreases),
    hovertemplate = bar.df$Decrease_Text,
    base = -as.numeric(bar.df$Significant_Decreases),
    marker = list(
      color = 'red'
    ),
    name = paste("Decreased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]))
fig <- fig %>% add_bars(
    x = bar.df$Class,
    y = as.numeric(bar.df$Significant_Increases),
    base = 0,
    hovertemplate = bar.df$Increase_Text,
    marker = list(
      color = 'blue'
    ),
     name = paste("Increased in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to",
                            str_split(contrasts[[i]],pattern="-")[[1]][2])
  )

fig <- fig %>% layout(title = paste("Significant changes by metabolite class\n(",contrasts[[i]],")"),
         xaxis = list(title = ""),
         #It would be better to set the range to min,max across all contrasts,
         #But that information is not available when each plot is drawn.
         yaxis = list(title = "",tick0=0, dtick=1,range = list(-max(data.frame(barplotminmax.vector)),max(data.frame(barplotminmax.vector)))),margin = list(l = 75, t = 150))
fig %>% layout(title="TEST")
barplotlist[[i]] = ggplotly(fig) 
} else
{
print("No metabolite classes with significant changes")
}
}
  }
htmltools::tagList(setNames(barplotlist, NULL))
  
}
```

## Volcano Plots

```{r}
if(test_type=="nostats"){
html_text <- "For FC analysis only, no volcano plots are included<br>"
htmltools::HTML(html_text)
}
```

```{r}
if(!test_type == "nostats"){

html_text <- "Hover over plot points to view compound labels.<br>Metabolites that pass the significance cutoff (but not fold-change) are orange, metabolites that pass the fold-change cutoff (but not significance) are black, and metabolites that pass both the fold-change and significance cutoffs are red. Metabolites in gray do not pass the significance or fold-change cutoff. If a color is missing from the plot, that is because no metabolites fall in that category. Adjusted p-value cutoff is 0.05, Fold-Change cutoff is 1.5.<br>"

htmltools::HTML(html_text)

#,fig.height=20,fig.width=8
volcanoplotlist = list()
for (i in 1:length(contrasts)){
##Volcano Plot
volcano.res <- Client_Data_Download[["report_results"]] %>% filter(contrast==contrasts[[i]])

#### Volcano plot of metabolites' fold-change highlights metabolites with different abundances between groups
#Hover over points to view significantly metabolite names
# add a grouping column; default value is "not significant"
volcano.res$group <- "NotSignificant"

# change the grouping for the entries with significance but not a large enough log2FC change
volcano.res[which(volcano.res$compound %in% sig_peaks[[i]] & volcano.res$row.ID %in% sig_peaks_rowID[[i]] & abs(volcano.res['log2FC']) < 0.58 ),"group"] <- "Significant"

# change the grouping for the entries a large enough log2FC change but not a low enough p value
volcano.res[which(abs(volcano.res['log2FC']) > 0.58 ),"group"] <- "log2FC"

# change the grouping for the entries with both significance and large enough log2FC change > 0.58
volcano.res[which(volcano.res$compound %in% sig_peaks[[i]]  & abs(volcano.res['log2FC']) > 0.58 ),"group"] <- "Significant&log2FC"

# make the Plot.ly plot
p <- plot_ly(data = volcano.res, x = volcano.res$log2FC, y = -log10(volcano.res[[p_type]]),hoverinfo = "text", text = paste(volcano.res$compound,volcano.res$ID_confidence,sep=":"),
             mode = "markers", color = volcano.res$group,colors = c(log2FC="black",NotSignificant="gray",Significant="orange",`Significant&log2FC`="red")) %>% 
  layout(title=paste("P-value vs. Fold-Change in",str_split(contrasts[[i]],pattern="-")[[1]][1],"relative to\n",
                            str_split(contrasts[[i]],pattern="-")[[1]][2]),
         xaxis = list(title = 'log2FC'), 
         yaxis = list(title = '-log10PVal'),margin = list(l = 75, t = 150))

    margin = list(l = 75, t = 150)

volcanoplotlist[[i]]=p
 }
htmltools::tagList(setNames(volcanoplotlist, NULL))
}
```

## Per-contrast boxplot of any of the top changed metabolites across sample class</span>\n

```{r}
if(test_type == "nostats"){
  html_text <- "Per-contrast boxplot of any of the top changed metabolites across sample class</span><br><br>"
} else {
  html_text <- "Per-contrast boxplot of any of the top significantly changed metabolites across sample class</span><br><br>"
}
htmltools::HTML(html_text)
```

For each contrast, the top changed metabolites are available to view as a boxplot of normalized peak intensity across sample class.

For some contrasts, dummy variables with no data (named beginning with X) have been added to the dropdown menu for ease of plotting. Please ignore.

Keep in mind boxplots display the median value of the data range, not the means (the comparison of which is used to calculate the test statistic and determine significance).

```{r,boxplot,echo=FALSE,warning=FALSE,message=FALSE,fig.dim = c(8, 4),eval=TRUE}
boxplotlist = list()
for (i in c(1:length(contrasts))){

#Manual changes needed for where metabolite data begins and for groupvar
## Order results by p.value values
if(p_type=="adj.p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,adj.p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]])  %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,adj.p.value)  %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]])  %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,p.value)  %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="log2FC"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}

#Combine - CHANGE where n:nrow begins depends on...number of metadata? 
#version update 2.1, previously the intensity data had header rows for metadata and so the matrices would first be subset by [num_of_metadata:nrow(matrix),], but it seems since using metaboanalayst I stopped doing this so now no rows are removed. Check back if it gets added again
normalized_int <- rbind(
  Client_Data_Download[["Pos.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Pos.normalized.data"]]),3:(num_samples+2)],
  Client_Data_Download[["Neg.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Neg.normalized.data"]]),3:(num_samples+2)])

rownames(normalized_int) <- c(paste(Client_Data_Download[["Pos.normalized.data"]]$row.ID,Client_Data_Download[["Pos.normalized.data"]]$mode,Client_Data_Download[["Pos.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))],paste(Client_Data_Download[["Neg.normalized.data"]]$row.ID,Client_Data_Download[["Neg.normalized.data"]]$mode,Client_Data_Download[["Neg.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))])

normalized_int <- filter(normalized_int, rownames(normalized_int) %in% top20_sigOE_genes)

rownames(normalized_int ) <- gsub("^\\d+_(Pos|Neg)_", "", rownames(normalized_int))

#The boxplot data frame is samples in rows metabs in cols, the normalized intensities for each sample preceded by the name and any metadata for that sample
my.df <- t(normalized_int)

#Truncate overly long colnames
colnames(my.df) <- substr(colnames(my.df), 1, 40)

#Add empty data columns to df if < 20 metabolites were significantly changed for a contrast
if(ncol(my.df)<20){
  add <- 20-ncol(my.df)
  add.df <- data.frame(matrix(ncol = add, nrow = nrow(my.df)))
  my.df <- cbind(my.df,add.df)
}

#add sample names and metadata to peak data
#rownames(my.df) <- gsub(".x","",rownames(my.df)) #I don't remember why these were there
my.df <- merge(Client_Data_Download[["metadata"]], my.df,by=0) %>% mutate_if(is.numeric, round,digits=4)
#####################################
#OPTIONAL To control the order of the x-axis . manual change arrange factor
if(length(class_order)>1){
xform <- list(categoryorder = "array",categoryarray = class_order)
}

num=ncol(my.df)-20+1
#Create the update drop-down menus
updatemenus <- list(
  #x=-.2,y = 0.9,
  list(direction = "down",
                x = -.3,
                y=0.9,
buttons = list(
list(method = "update",
    args = list(list(visible=c(TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                           list(yaxis = list(title = "Peak intensity"))),
label = colnames(my.df[num])),
list(method = "update",
     args = list(list(visible=c(FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                           list(yaxis = list(title = "Peak intensity"))),
               label = colnames(my.df[num+1])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+2])),
list(method = "update",
     args = list(list(visible=c(FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+3])),
list(method = "update",
     args = list(list(visible=c(FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+4])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+5])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+6])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+7])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+8])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+9])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+10])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+11])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+12])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+13])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+14])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+15])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+16])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+17])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+18])),
list(method = "update",
     args = list(list(visible=c(FALSE, FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE)),
                 list(yaxis = list(title = "Peak intensity"))),
     label = colnames(my.df[num+19]))
    )))
m <- list(l = 220,r = 50,b = 50,t = 50)
plot <- plot_ly(data=my.df, x = boxplot_var,color = I("gray"),yaxis = list(title = "Peak intensity"))

if(length(class_order)>1){
 plot <- plot %>%layout(xaxis=xform)
 }

plot <- plot %>%

add_boxplot(x=boxplot_var,y = my.df[,num],visible=TRUE)%>%
add_boxplot(x=boxplot_var,y = my.df[,num+1], visible =FALSE)%>%
add_boxplot(x=boxplot_var,y = my.df[,num+2], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+3], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+4], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+5], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+6], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+7], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+8], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+9], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+10], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+11], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+12], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+13], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+14], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+15], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+16], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+17], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+18], visible = FALSE) %>%
  add_boxplot(x=boxplot_var,y = my.df[,num+19], visible = FALSE) %>%

#Add the buttons to update
layout(updatemenus =updatemenus,
  title = paste("Boxplot of peak intensities across ",Grouping_Variable),
    showlegend = FALSE,color="gray",yaxis = list(title = "Peak intensity")) %>%

#Add plot annotations
add_annotations(x = 'center',y = 1.05, text = paste("Top metabolites ",contrasts[[i]],sep=""),
xref = "paper",yref = "paper",
showarrow = FALSE) %>% layout(autosize = F, width = 800, height = 400, margin = m)

boxplotlist[[i]]=plot #this works if you just print(plot), the plots are right
}
htmltools::tagList(boxplotlist)
```

## Per-contrast violin plot of any of the top changed metabolites across sample class</span>\n

```{r}
if(test_type == "nostats"){
  html_text <- "Per-contrast violin plo of any of the top changed metabolites across sample class</span><br><br>"
} else {
  html_text <- "Per-contrast violin plo of any of the top significantly changed metabolites across sample class</span><br><br>"
}
htmltools::HTML(html_text)
```

```{r violin}
violinplotlist = list()
for (i in c(1:length(contrasts))) {
my.df <- my.df %>%
  mutate_at(vars(4:ncol(.)), ~ as.numeric(as.character(.))) %>%
  mutate_at(vars(4:ncol(.)), ~ round(., 2))

  updatemenus <- list(
    list(direction = "down",
         x = -.3,
         y = 0.9,
         buttons = lapply(0:19, function(idx) {
           visibility <- rep(FALSE, 20)
           visibility[idx + 1] <- TRUE
           list(
             method = "restyle",
             args = list("visible", visibility),
             label = colnames(my.df)[num + idx]
           )
         })
    )
  )

  m <- list(l = 220, r = 50, b = 50, t = 50)

  # Create plotly object with all traces
  plot <- plot_ly()

  # Add each trace to the plot
  for (j in 0:19) {
    plot <- plot %>%
      add_trace(
        type = 'violin',
        x = ~my.df$Class,
        y = my.df[, num + j],
        points = "all",
        jitter = 0.3,
        pointpos = 0,
        hoverinfo = 'text',
        text = ~paste('Sample:', my.df$Sample.name),
        visible = ifelse(j == 0, TRUE, FALSE),  # Make only the first trace visible initially
        name = colnames(my.df)[num + j]
      )
  }

  # Create update menus
  updatemenus <- list(
    list(
      buttons = lapply(0:19, function(idx) {
        visibility <- rep(FALSE, 20)
        visibility[idx + 1] <- TRUE
        list(
          method = "restyle",
          args = list("visible", visibility),
          label = colnames(my.df)[num + idx]
        )
      }),
      direction = "down",
      x = -0.1,
      y = 1.2
    )
  )

  # Final plot with update menus
  plot <- plot %>%
    layout(
      updatemenus = updatemenus,
      title = list(
        text = "Violin plot of peak intensities across Class",
        x = 0.7,  # Adjust this value between 0 and 1 to move the title
        xanchor = "center"  # Adjust anchor point based on x value
      ),
      showlegend = FALSE,
      yaxis = list(
        title = "Peak intensity",
        showticklabels = TRUE,
        autorange = TRUE,  # Ensure autorange is set to handle both positive and negative values
        tickmode = "linear",
        dtick = 0.5,  # Adjust this value to control tick intervals
        tickformat = ".2f"  # Round the tick labels to 2 decimal places
      ),
      xaxis = list(title = "Class")  # Change x-axis title to "Class"
    )

  violinplotlist[[i]] = plot
}

#htmltools::tagList(violinplotlist)
plot
```

## Heatmaps of changed metabolites

```{r}
if(test_type == "nostats"){
  html_text <- "Heatmaps of metabolites with greatest log2FC difference in abundance</span><br><br>"
} else {
  html_text <- "Heatmaps of metabolites with most significant difference in abundance</span><br><br>"
}
htmltools::HTML(html_text)
```

For each contrast, the top changed metabolites are available to view as a heatmap of normalized peak intensity. Samples (columns) are clustered by the peak intensities for the displayed set of compounds.

Hover and select a subset of metabolites or samples of interest to export a zoomed-in subfigure

```{r,heatmap,echo=FALSE,warning=FALSE,message=FALSE,fig.dim = c(10, 12)}
heatmaplist=list()
for (i in 1:length(contrasts)){
  
#Manual changes needed for where metabolite data begins and for groupvar
## Order results by p.value values
if(p_type=="adj.p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,adj.p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]])  %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,adj.p.value)  %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="p.value"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,p.value) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast==contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]])  %>% mutate(ID_confidence = factor(ID_confidence, levels = c("High", "Low", ""), ordered = TRUE)) %>%
  arrange(ID_confidence,p.value)  %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
if(p_type=="log2FC"){
  top20_sigOE_genes <- paste(Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(row.mode) %>% unlist(),
  Client_Data_Download[["report_results"]] %>% filter(contrast == contrast[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>% arrange(desc(log2FC)) %>% slice_head(n=20) %>% select(compound) %>% unlist(),sep="_")
}
#detected in positive 

#Combine - CHANGE where n:nrow begins depends on...number of metadata? not usre
normalized_int <- rbind(
  Client_Data_Download[["Pos.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Pos.normalized.data"]]),3:(num_samples+2)],
  Client_Data_Download[["Neg.normalized.data"]][num_of_metadata:nrow(Client_Data_Download[["Neg.normalized.data"]]),3:(num_samples+2)])

rownames(normalized_int) <- c(paste(Client_Data_Download[["Pos.normalized.data"]]$row.ID,Client_Data_Download[["Pos.normalized.data"]]$mode,Client_Data_Download[["Pos.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))],paste(Client_Data_Download[["Neg.normalized.data"]]$row.ID,Client_Data_Download[["Neg.normalized.data"]]$mode,Client_Data_Download[["Neg.normalized.data"]]$compound,sep="_")[-c(1:(num_of_metadata-1))])

normalized_int <- filter(normalized_int, rownames(normalized_int) %in% top20_sigOE_genes)

normalized_int <- mutate_all(normalized_int, function(x) as.numeric(as.character(x)))

temp.normalized.int <- t(normalized_int)

sidecols <- data.frame(Client_Data_Download[["metadata"]] %>% select(colnames(Client_Data_Download[["metadata"]][2:ncol(Client_Data_Download[["metadata"]])]))) %>% select(contrast_var)
temp.normalized.int <- merge(temp.normalized.int,sidecols,by=0)

#The code below can be resurrected if we decide to label more than one contrast_var, but currently the code above only selected a single contrast_var to annotate 
#Everything else was commented out for a dataset with > 1 metadata, but is it even needed for 1 metadata? Check ASAP
#sidecols <- temp.normalized.int[,c(1,(ncol(temp.normalized.int)-(num_of_metadata-2)):ncol(temp.normalized.int))] #What was this for
##arrange the sidecols by the colnames in 
#rownames(sidecols) <- sidecols$Row.names
#sidecols <- data.frame(sidecols[,-1])
#colnames(sidecols) <- colnames(Client_Data_Download[["metadata"]][2:ncol(Client_Data_Download[["metadata"]])])

normalized_int <- data.frame(t(temp.normalized.int))
colnames(normalized_int) <- normalized_int[1,]
normalized_int <- normalized_int[-1,]
normalized_int <- normalized_int %>% filter(!row.names(normalized_int) %in% colnames(Client_Data_Download[["metadata"]]))
normalized_int <- mutate_all(normalized_int, function(x) as.numeric(as.character(x)))
#
rownames(normalized_int) <- substr(rownames(normalized_int), 1, 40)

# Fix the column names to match the row names of sidecols
matching_indices <- match(rownames(sidecols), colnames(normalized_int))

# Reorder columns in normalized_int to match the sidecols row order
normalized_int <- normalized_int[, matching_indices, drop = FALSE]

if(nrow(normalized_int)>1){
  if(test_type=="nostats"){
    hm <-   heatmaply(plot_method = "plotly",normalized_int,show_dendrogram = FALSE,showticklabels=c(FALSE, TRUE),scale="row",
          colors=c("darkblue","white","darkred"),
          #Make this the annotation bar
          col_side_colors = sidecols,xlab = "Samples",
  ylab = "Metabolites", 
  main = paste("Peak heights (scaled) for most changed metabolites\n",contrasts[[i]],sep=""),margins=c(0,0,60,0),fontsize_row = 5,cex.main=1,labRow=gsub("\\d+_\\w+_","",(rownames(normalized_int))),side_color_colorbar_len = .5)

heatmaplist[[i]]=hm
    
  }else{
hm <-   heatmaply(plot_method = "plotly",normalized_int,show_dendrogram = FALSE,showticklabels=c(FALSE, TRUE),scale="row",
          colors=c("darkblue","white","darkred"),
          #Make this the annotation bar
          col_side_colors = sidecols,xlab = "Samples",
  ylab = "", 
  main = paste("Peak heights (scaled) for most significantly changed metabolites\n",contrasts[[i]],sep=""),margins=c(0,0,60,0),fontsize_row = 12,cex.main=1,labRow=gsub("\\d+_\\w+_","",(rownames(normalized_int))),side_color_colorbar_len = .5)

heatmaplist[[i]]=hm
}
}
}
htmltools::tagList(setNames(heatmaplist, NULL))
```

## Pathway Visualization with KEGG and Pathview

Pathway analysis was performed using the R package Pathview (https://bioconductor.org/packages/release/bioc/html/pathview.html). This method leverages the KEGG database to map and visualize metabolites onto relevant biochemical pathways. Starting from a list of up-regulated and down-regulated metabolites, Pathview generates detailed pathway diagrams highlighting the changes in metabolic activity.

This approach is more inclusive than Metabolite Set Enrichment Analysis (MSEA) (which provides statistical significance for enrichment of metabolite sets in pathways). Pathview offers a broader visualization by mapping all input metabolites onto KEGG pathways, allowing for a comprehensive view of metabolic changes. This method can identify affected pathways that might not reach statistical significance in MSEA but may still be biologically relevant.

The input changed metabolites are indicated by colored nodes in the pathways (blue is decreased, yellow is increased).

**If your study/contrast yielded > 20 significantly changed compounds with high-confidence IDs, only high-confidence IDs are included as input compounds.**

```{r,out.width = "100%",out.height = "auto", results='asis',dpi=300}
library(KEGGREST)
library(pathview)

# Set output directory
output_dir <- paste0("/blue/timgarrett/hkates/SECIM_Reporting/",client,"Deletable")

# Ensure the output directory exists
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# compound data
if(sig_knowns < 20){
  up_compounds <- Client_Data_Download[["report_results"]] %>% 
    filter(contrast==contrasts[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>%
           filter(log2FC > 0) %>% filter(str_trim(KEGG) != "") %>% pull(KEGG)
  down_compounds <- Client_Data_Download[["report_results"]] %>% 
    filter(contrast==contrasts[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>%
           filter(log2FC < 0) %>% filter(str_trim(KEGG) != "") %>% pull(KEGG)} else{
        up_compounds <- Client_Data_Download[["report_results"]] %>% 
    filter(contrast==contrasts[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>%
           filter(log2FC > 0) %>% filter(ID_confidence=="High") %>% filter(str_trim(KEGG) != "") %>% pull(KEGG)
         down_compounds <- Client_Data_Download[["report_results"]] %>% 
    filter(contrast==contrasts[[i]]) %>% filter(compound %in% sig_peaks[[contrasts[[i]]]]) %>%
           filter(log2FC < 0) %>% filter(ID_confidence=="High") %>% filter(str_trim(KEGG) != "")%>% pull(KEGG)
           }

# Add +1 or -1 to each compound
cpd_data <- c(setNames(rep(1, length(up_compounds)), up_compounds),
              setNames(rep(-1, length(down_compounds)), down_compounds))

# Function to get pathways for a given compound
get_pathways <- function(compound_id) {
  pathway_list <- keggLink("pathway", paste0("cpd:", compound_id))
  return(gsub("path:", "", pathway_list))
}

# Get pathways for each compound
compound_pathways <- unique(unlist(lapply(names(cpd_data), get_pathways)))

# Validate pathway IDs
validate_pathway <- function(pathway_id) {
  tryCatch({
    res <- keggGet(pathway_id)
    return(length(res) > 0)
  }, error = function(e) {
    return(FALSE)
  })
}

valid_pathways <- unique(compound_pathways[sapply(compound_pathways, validate_pathway)])

# Function to get pathway categories
get_pathway_categories <- function(pathways) {
  # Split pathways into chunks of 10
  pathway_chunks <- split(pathways, ceiling(seq_along(pathways) / 10))
  
  # Initialize an empty list to store categories
  all_categories <- list()
  
  # Process each chunk
  for (chunk in pathway_chunks) {
    pathway_info <- keggGet(chunk)
    categories <- sapply(pathway_info, function(info) {
      if ("CLASS" %in% names(info)) {
        return(info$CLASS)
      } else {
        return(NA)
      }
    })
    all_categories <- c(all_categories, categories)
  }
  
  # Convert the list to a named vector
  names(all_categories) <- pathways
  return(unlist(all_categories))
}

# Get pathway categories
pathway_categories <- get_pathway_categories(valid_pathways)

# Additional global categories to filter out
global_categories <- c("Metabolism", "Genetic Information Processing", "Environmental Information Processing",
                       "Cellular Processes", "Organismal Systems", "Human Diseases", "Drug Development",
                       "Metabolic pathways", "Biosynthesis of secondary metabolites",
                       "Microbial metabolism in diverse environments", "Carbon metabolism", "Biosynthesis of antibiotics",
                       "Global and Overview Maps")

# Filter out global pathways
filtered_pathways <- names(pathway_categories)[!sapply(pathway_categories, function(cat) {
  is.na(cat) || any(global_categories %in% cat)
})]

# Convert pathways to "hsa" format
filtered_pathways <- gsub("map","hsa", filtered_pathways)
library(httr)
library(xml2)

# Function to visualize pathways and track errors
visualize_pathway <- function(pathway_id, cpd_data, output_dir, error_list) {
  # Save the current working directory
  current_dir <- getwd()
  # Set the working directory to the output directory
  setwd(output_dir)
  
  result <- tryCatch({
    pathview(gene.data = NULL, cpd.data = cpd_data, pathway.id = pathway_id, species = "hsa", out.suffix = pathway_id, kegg.native = TRUE)
    TRUE
  }, warning = function(w) {
    message(sprintf("Warning in pathway %s: %s", pathway_id, w$message))
    FALSE
  }, error = function(e) {
    message(sprintf("Error in pathway %s: %s", pathway_id, e$message))
    FALSE
  }, finally = {
    # Restore the original working directory
    setwd(current_dir)
  })

  # If the pathway download fails, try using the generic prefix
  if (!result) {
    generic_pathway_id <- sub("^hsa", "map", pathway_id)
    
    # Check if the generic pathway is available
    pathway_url <- paste0("https://rest.kegg.jp/get/", generic_pathway_id)
    response <- GET(pathway_url)
    if (status_code(response) == 200) {
      # Extract the KO_PATHWAY id from the generic pathway entry
      pathway_content <- content(response, as = "text")
      ko_pathway_id <- sub("^map", "ko", generic_pathway_id)
      
      # Use the KO_PATHWAY id to fetch the KGML file
      result <- tryCatch({
        setwd(output_dir) # Ensure working directory is still set to output_dir
        pathview(gene.data = NULL, cpd.data = cpd_data, pathway.id = ko_pathway_id, species = "ko", out.suffix = ko_pathway_id, kegg.native = TRUE)
        TRUE
      }, warning = function(w) {
        message(sprintf("Warning in KO_PATHWAY %s: %s", ko_pathway_id, w$message))
        FALSE
      }, error = function(e) {
        message(sprintf("Error in KO_PATHWAY %s: %s", ko_pathway_id, e$message))
        FALSE
      }, finally = {
        # Restore the original working directory
        setwd(current_dir)
      })
      
      if (!result) {
        error_list <<- c(error_list, pathway_id)
      } else {
        pathway_id <- ko_pathway_id
      }
    } else {
      error_list <<- c(error_list, pathway_id)
    }
  }

  return(pathway_id)
}

# Initialize a list to store image file paths and a list to track errors
image_files <- list()
error_list <- list()

# Loop through each filtered pathway and visualize
for (pathway_id in filtered_pathways) {
  pathway_id <- visualize_pathway(pathway_id, cpd_data, output_dir, error_list)
  # Correct the image file name pattern to match the generated files
  img_file <- file.path(output_dir, paste0(pathway_id, ".", pathway_id, ".png"))
  if (file.exists(img_file)) {
    image_files <- c(image_files, img_file)
  }
}

# Flatten the list of image files to a character vector
image_files <- unlist(image_files)

# Print a message listing the pathways that could not be downloaded
if (length(error_list) > 0) {
  cat("The following pathways include one or more of the input compounds, but could not be downloaded from KEGG and are not displayed:\n")
  cat(paste(error_list, collapse = ", "), "\n")
}

# Set up the title and subtitle
title <- paste("Yellow nodes are compounds increased in", str_split(contrasts[[i]], pattern="-")[[1]][1], 
                  "relative to", str_split(contrasts[[i]], pattern="-")[[1]][2], 
                  ". Blue nodes are compounds decreased in", str_split(contrasts[[i]], pattern="-")[[1]][1], 
                  "relative to", str_split(contrasts[[i]], pattern="-")[[1]][2], ".")

# Print the title and subtitle
cat(paste0("**", title,"**<br><br>"))

cat(paste0("**","Download higher resolution pathway images","**","\n"))

# Create a download button for the images as a zip file
## Create a dedicated directory
library(zip)
library(fs)
# Create a dedicated directory
output_dir <- paste0("/blue/timgarrett/hkates/SECIM_Reporting/",client,"Deletable/","pathway_images")
dir_create(output_dir)

# Copy image files to the dedicated directory
invisible(file.copy(image_files, output_dir))

# Create a zip file
zip_file <- paste0("/blue/timgarrett/hkates/SECIM_Reporting/",client,"Deletable/","pathway_images.zip")
zip(zip_file, files = list.files(output_dir, full.names = TRUE))

xfun::embed_file(paste0("/blue/timgarrett/hkates/SECIM_Reporting/",client,"Deletable/","pathway_images.zip"))

knitr::include_graphics(image_files)
```
